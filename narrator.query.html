<html lang="en">
  <head>
    <title>narrator.query documentation</title>
    <link href="css/default.css" type="text/css" rel="stylesheet" />
    <link href="css/codox-md.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/page_effects.js"></script>
  </head>
  <body>
    <header>
      <div id="header">
        <h1 class="project-title">Narrator 0.1.1-SNAPSHOT API documentation</h1>
      </div>
    </header>
    <navigation>
      <div id="namespaces" class="sidebar">
        <h3>Namespaces</h3>
        <ul class="ns-links">
          <li class="ns-list"><a class="ns-link ns-name" href="narrator.core.html">narrator.core</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.executor.html">narrator.executor</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.operators.sampling.html">narrator.operators.sampling</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.operators.streaming.html">narrator.operators.streaming</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.query.html">narrator.query</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.utils.locks.html">narrator.utils.locks</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.utils.math.html">narrator.utils.math</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.utils.rand.html">narrator.utils.rand</a></li><li class="ns-list"><a class="ns-link ns-name" href="narrator.utils.time.html">narrator.utils.time</a></li>
        </ul>
      </div>
      <div id="vars" class="sidebar">
        <h3>Public Vars</h3>
        <ul class="ns-var-links">
          <li class="ns-var-list"><a class="ns-var-link ns-var-name" href="narrator.query.html#var-combiner">combiner</a></li><li class="ns-var-list"><a class="ns-var-link ns-var-name" href="narrator.query.html#var-query-channel">query-channel</a></li><li class="ns-var-list"><a class="ns-var-link ns-var-name" href="narrator.query.html#var-query-lamina-channel">query-lamina-channel</a></li><li class="ns-var-list"><a class="ns-var-link ns-var-name" href="narrator.query.html#var-query-seq">query-seq</a></li>
        </ul>
      </div>
    </navigation>
    <article>
      <div id="content" class="namespace-docs">
        <h2 class="namespace-title">narrator.query documentation</h2>
        <div class="doc">
</div>
        <div class="ns-vars">
          <div class="public">
            <h3><a id="var-combiner" class="source var-name" href="src/narrator/query.clj">combiner</a></h3>
            <h4 class="var-type fn" id="var-type">fn</h4>
            <div class="usage">[query-descriptor]</div><div class="usage">[query-descriptor {:keys [deserialize], :or {deserialize identity}}]</div>
            
            
            <div class="doc"><p>Returns a function that combines the output of :partial queries.</p>
</div>
          </div><div class="public">
            <h3><a id="var-query-channel" class="source var-name" href="src/narrator/query.clj">query-channel</a></h3>
            <h4 class="var-type fn" id="var-type">fn</h4>
            <div class="usage">[query-descriptor {:keys [period timestamp value start-time buffer? block-size mode serialize], :or {value identity, mode :full, serialize identity, period Long/MAX_VALUE}, :as options} ch]</div>
            
            
            <div class="doc"><p>Behaves like <code>query-seq</code>, except that the input is assumed to be a core.async channel, and the return value is also
a core.async channel.  A <code>:period</code> must be provided.  If no <code>:timestamp</code> is given, then the analysis will occur in
realtime, emitting query results  periodically without any timestamp.  If <code>:timestamp</code> is given, then it will emit
maps with <code>:timestamp</code> and <code>:value</code> entries whenever a period elapses in the input stream.</p>
</div>
          </div><div class="public">
            <h3><a id="var-query-lamina-channel" class="source var-name" href="src/narrator/query.clj">query-lamina-channel</a></h3>
            <h4 class="var-type fn" id="var-type">fn</h4>
            <div class="usage">[query-descriptor {:keys [period timestamp value start-time buffer? block-size mode serialize], :or {value identity, period Long/MAX_VALUE, mode :full, serialize identity}, :as options} ch]</div>
            
            
            <div class="doc"><p>Behaves like <code>query-seq</code>, except that the input is assumed to be a Lamina channel, and the return value is also
a Lamina channel.  A <code>:period</code> must be provided.  If no <code>:timestamp</code> is given, then the analysis will occur in
realtime, emitting query results  periodically without any timestamp.  If <code>:timestamp</code> is given, then it will emit
maps with <code>:timestamp</code> and <code>:value</code> entries whenever a period elapses in the input stream.</p>
</div>
          </div><div class="public">
            <h3><a id="var-query-seq" class="source var-name" href="src/narrator/query.clj">query-seq</a></h3>
            <h4 class="var-type fn" id="var-type">fn</h4>
            <div class="usage">[query-descriptor s]</div><div class="usage">[query-descriptor {:keys [start-time period timestamp value buffer? block-size], :or {value identity}, :as options} s]</div>
            
            
            <div class="doc"><p>Applies the <code>query-descriptor</code> to the sequence of messages.  If <code>:timestamp</code> and <code>:period</code> are specified, then returns
a sequence of maps containing <code>:timestamp</code> and <code>:value</code> entries, representing the output of the query between that
timestamp and the previous one.  If they are not specified, then a single result is returned, representing the consumption
of the entire sequence.</p>

<pre><code>(query-seq rate (range 10)) =&gt; 10

(query-seq rate {:period 5, :timestamp identity} (range 10)) =&gt; ({:timestamp 5, :value 5} {:timestamp 10, :value 5})
</code></pre>

<p>This behaves lazily; elements of the input seq will only be consumed when elements from the output seq are consumed.</p>

<p>Optional arguments:</p>

<p><code>start-time</code> - the beginning of time, defaults to the timestamp of the first element
<code>value</code> - the actual payload of the incoming messages that should be queried, defaults to <code>identity</code>
<code>buffer?</code> - if true, messages are not immediately processed, and may be processed in parallel, defaults to true
<code>block-size</code> - the size of the messages buffers, defaults to 1024</p>
</div>
          </div>
        </div>
      </div>
    </article>
  </body>

</html>